{"unit_id": "REQ-169::au001", "req_id": "REQ-169", "doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "parent_sent_id": "REQ-169::s006", "order": 1, "text": "encountering a bracketed index that fails this pattern"}
{"unit_id": "REQ-169::au002", "req_id": "REQ-169", "doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "parent_sent_id": "REQ-169::s006", "order": 2, "text": "that fails this pattern"}
{"unit_id": "REQ-169::au003", "req_id": "REQ-169", "doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "parent_sent_id": "REQ-169::s006", "order": 3, "text": "On encountering a bracketed index that fails this pattern , the lexer should immediately raise error code QASM102 ( “ Invalid QASM index : must be integer ≥ 0 ” ) , halting further parsing ."}
{"unit_id": "REQ-169::au004", "req_id": "REQ-169", "doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "parent_sent_id": "REQ-169::s006", "order": 4, "text": "halting further parsing"}
{"unit_id": "REQ-169::au005", "req_id": "REQ-169", "doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "parent_sent_id": "REQ-169::s009", "order": 5, "text": "Patch  \n In ` lexer.l ` , insert the following rule before the integer rule :  \n ` ` ` \n \\[\\s*([^\\d][^\\]]*)\\s*\\"}
{"unit_id": "REQ-169::au006", "req_id": "REQ-169", "doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "parent_sent_id": "REQ-169::s009", "order": 6, "text": "insert the following rule before the integer rule :"}
{"unit_id": "REQ-169::au007", "req_id": "REQ-169", "doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "parent_sent_id": "REQ-169::s009", "order": 7, "text": "]     { return error(QASM102 ,"}
{"unit_id": "REQ-169::au008", "req_id": "REQ-169", "doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "parent_sent_id": "REQ-169::s009", "order": 8, "text": "to match ` \\[\\s*\\d+\\s*\\ ]"}
