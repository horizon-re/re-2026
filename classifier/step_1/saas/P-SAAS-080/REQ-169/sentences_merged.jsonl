{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s001", "order": 1, "text": "Issue  \nThe QASM compiler’s current grammar permits register declarations with indices that are non-integer or negative values (e.g., `qreg q[-1]; qreg q[1.5]; qreg q[π];`).", "char_start": 0, "char_end": 173, "splitter": "merged", "token_count": 40, "verified_by_other": true}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s002", "order": 2, "text": "These invalid indices lead to undefined behavior in later compilation stages, causing unpredictable runtime faults and hindering compiler reliability.", "char_start": 174, "char_end": 324, "splitter": "merged", "token_count": 21, "verified_by_other": true}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s003", "order": 3, "text": "Because the lexer does not distinguish integer-only index tokens, invalid inputs slip through and produce ambiguous errors downstream rather than a targeted diagnostic.", "char_start": 325, "char_end": 493, "splitter": "merged", "token_count": 27, "verified_by_other": true}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s004", "order": 4, "text": "This defect has been observed in both development and production builds, leading to delayed deployment cycles.", "char_start": 494, "char_end": 606, "splitter": "merged", "token_count": 19, "verified_by_other": true}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s005", "order": 5, "text": "Validation  \nIntroduce a fast-fail lexer rule that matches any array index token not conforming to the pattern of one or more decimal digits (regex `\\d+`).", "char_start": 606, "char_end": 761, "splitter": "merged", "token_count": 33, "verified_by_other": true}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s006", "order": 6, "text": "On encountering a bracketed index that fails this pattern, the lexer should immediately raise error code QASM102 (“Invalid QASM index: must be integer ≥ 0”), halting further parsing.", "char_start": 762, "char_end": 944, "splitter": "merged", "token_count": 36, "verified_by_other": true}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s007", "order": 7, "text": "Add a unit test case where a register declaration uses the Unicode constant π as an index (`qreg q[π];`) and assert that lexing fails with QASM102.", "char_start": 945, "char_end": 1092, "splitter": "merged", "token_count": 33, "verified_by_other": true}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s008", "order": 8, "text": "Also include negative and floating-point index tests (`qreg q[-1]; qreg q[2.3];`) to ensure comprehensive coverage.", "char_start": 1093, "char_end": 1210, "splitter": "merged", "token_count": 27, "verified_by_other": true}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s009", "order": 9, "text": "Patch  \nIn `lexer.l`, insert the following rule before the integer rule:  \n```\n\\[\\s*([^\\d][^\\]]*)\\s*\\]    { return error(QASM102, \"Index must be integer ≥ 0\"); }\n```  \nRefactor the existing integer-index rule to match `\\[\\s*\\d+\\s*\\]`.", "char_start": 1210, "char_end": 1444, "splitter": "merged", "token_count": 58, "verified_by_other": true}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s010", "order": 10, "text": "Extend the unit test suite (e.g., `test/lexer_invalid_index.qasm`) with tests:  \n```\nqreg q[π];    // expect QASM102  \nqreg q[-1];   // expect QASM102  \nqreg q[2.3];  // expect QASM102  \n```  \nRun `make test` to confirm failure on invalid cases and success on valid declarations.", "char_start": 1445, "char_end": 1724, "splitter": "merged", "token_count": 70, "verified_by_other": true}
