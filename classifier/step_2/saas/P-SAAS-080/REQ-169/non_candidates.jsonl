{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s001", "order": 1, "text": "Issue  \nThe QASM compiler’s current grammar permits register declarations with indices that are non-integer or negative values (e.g., `qreg q[-1]; qreg q[1.5]; qreg q[π];`).", "is_candidate": false, "signals": {"action": true, "modal": false, "system": false, "constraint": false}}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s002", "order": 2, "text": "These invalid indices lead to undefined behavior in later compilation stages, causing unpredictable runtime faults and hindering compiler reliability.", "is_candidate": false, "signals": {"action": true, "modal": false, "system": false, "constraint": false}}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s003", "order": 3, "text": "Because the lexer does not distinguish integer-only index tokens, invalid inputs slip through and produce ambiguous errors downstream rather than a targeted diagnostic.", "is_candidate": false, "signals": {"action": true, "modal": false, "system": false, "constraint": false}}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s004", "order": 4, "text": "This defect has been observed in both development and production builds, leading to delayed deployment cycles.", "is_candidate": false, "signals": {"action": true, "modal": false, "system": false, "constraint": false}}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s005", "order": 5, "text": "Validation  \nIntroduce a fast-fail lexer rule that matches any array index token not conforming to the pattern of one or more decimal digits (regex `\\d+`).", "is_candidate": false, "signals": {"action": true, "modal": false, "system": false, "constraint": false}}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s007", "order": 7, "text": "Add a unit test case where a register declaration uses the Unicode constant π as an index (`qreg q[π];`) and assert that lexing fails with QASM102.", "is_candidate": false, "signals": {"action": true, "modal": false, "system": false, "constraint": false}}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s008", "order": 8, "text": "Also include negative and floating-point index tests (`qreg q[-1]; qreg q[2.3];`) to ensure comprehensive coverage.", "is_candidate": false, "signals": {"action": true, "modal": false, "system": false, "constraint": false}}
{"doc_id": "f9370a50-5856-5d3d-8716-7e9f7dbaf705", "req_id": "REQ-169", "sent_id": "REQ-169::s010", "order": 10, "text": "Extend the unit test suite (e.g., `test/lexer_invalid_index.qasm`) with tests:  \n```\nqreg q[π];    // expect QASM102  \nqreg q[-1];   // expect QASM102  \nqreg q[2.3];  // expect QASM102  \n```  \nRun `make test` to confirm failure on invalid cases and success on valid declarations.", "is_candidate": false, "signals": {"action": true, "modal": false, "system": false, "constraint": false}}
